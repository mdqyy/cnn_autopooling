function [out, indices] = order(in, ratio, operation)
% Apply an ordering (sorting) operation to a ratio x ratio region in the
% input, in.
% 
% INPUTS
% in - the input data
% ratio - integer, representing the side length of the region to process
% operation - string, representing the type of ordering operation.
% { 'descend', 'ascend' }. By default, sorting is done column-wise, e.g.:
%
% in
% [ 3   6   1;
%   2   2   9;
%   8   4   5]
%
% out
% [ 6   2   9   2;
%   3   2   6   1;
%   8   2   9   4;
%   4   2   5   2]
%
% indices
% [ 4   2   
%
%
%
% OUTPUTS
% out - the data with ordered ratio x ratio regions. The regions overlap by
% stride=1, therefore the output is larger.
% indices - the index of each element in the original matrix
%

if nargin < 3
    operation = 'descend'; % default: sort in descending order
end

% The size of the output
out = nan((size(in,1)-ratio+1)*2,(size(in,2)-ratio+1)*2);

% Assuming a stride of 1
for k=1:size(in,1)-ratio+1
    for m=1:size(in,2)-ratio+1
        % Sort the next region
        nextRegion = in(k:k+ratio-1,m:m+ratio-1);
        [sortedRegion, ix] = sort(nextRegion(:), operation);
        % TODO: ix is the index within nextRegion, need to adjust for 
        % overall matrix indices. Use ix as index into the 
        out((k-1)*ratio+1:k*ratio,(m-1)*ratio+1:m*ratio) = reshape(sortedRegion,ratio,ratio);
    end
end        

end